name: CD - Auto Bump Version

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write

jobs:
  bump:
    runs-on: ubuntu-latest
    if: "endsWith(github.event.head_commit.message, '[release]') || github.event_name == 'workflow_dispatch'"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GH_PAT }}

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: 'stable'
          flutter-version: '3.22.0'

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Install dependencies
        run: flutter pub get

      - name: Auto-Bump Version
        id: bump
        run: |
          # Create a Dart script to handle the smart version bumping and changelog validation
          cat <<EOF > bump_version.dart
          import 'dart:io';
          import 'dart:convert';

          void main() async {
            // 1. Read local pubspec.yaml
            final pubspecFile = File('pubspec.yaml');
            if (!pubspecFile.existsSync()) {
               print('Error: pubspec.yaml not found');
               exit(1);
            }
            final lines = await pubspecFile.readAsLines();
            String? name;
            String? localVersionStr;
            
            for (var line in lines) {
              if (line.trim().startsWith('name:')) {
                name = line.split(':')[1].trim();
              } else if (line.trim().startsWith('version:')) {
                localVersionStr = line.split(':')[1].trim();
              }
            }

            if (name == null || localVersionStr == null) {
              print('Error: Could not find name or version in pubspec.yaml');
              exit(1);
            }

            print('Package: \$name');
            print('Local Version: \$localVersionStr');

            // 2. Fetch latest version from pub.dev
            String? publishedVersionStr;
            final client = HttpClient();
            try {
              final url = Uri.parse('https://pub.dev/api/packages/\$name');
              final request = await client.getUrl(url);
              final response = await request.close();
              if (response.statusCode == 200) {
                final body = await response.transform(utf8.decoder).join();
                final json = jsonDecode(body);
                publishedVersionStr = json['latest']['version'];
                print('Published Version: \$publishedVersionStr');
              } else {
                print('Package not found on pub.dev or API error (Status \${response.statusCode}). Assuming first release.');
              }
            } catch (e) {
              print('Error checking pub.dev: \$e');
            } finally {
              client.close();
            }

            // 3. Determine Next Version
            String nextVersion = localVersionStr!;
            if (publishedVersionStr != null) {
              final local = _parseVersion(localVersionStr);
              final published = _parseVersion(publishedVersionStr);

              if (_isGreater(published, local) || _isEqual(published, local)) {
                // If published is >= local, we must bump published to get next
                // Defaulting to patch bump with 9->0 rollover
                int maj = published[0];
                int min = published[1];
                int pat = published[2];

                if (pat < 9) {
                  pat++;
                } else {
                  pat = 0;
                  if (min < 9) {
                    min++;
                  } else {
                    min = 0;
                    maj++;
                  }
                }
                nextVersion = '\$maj.\$min.\$pat';
                print('Published version >= Local version. Bumping to \$nextVersion');
              } else {
                print('Local version is already ahead. Using \$nextVersion');
              }
            }

            // 4. Verify CHANGELOG.md (CRITICAL STEP)
            print('üîç Verifying CHANGELOG.md for version \$nextVersion...');
            final changelogFile = File('CHANGELOG.md');
            if (!changelogFile.existsSync()) {
              print('‚ùå Error: CHANGELOG.md file not found!');
              exit(1);
            }
            
            final changelogContent = changelogFile.readAsStringSync();
            final expectedHeader = '## [\$nextVersion]';
            
            if (!changelogContent.contains(expectedHeader)) {
               print('‚ùå Error: Missing changelog entry for version \$nextVersion');
               print('-------------------------------------------------------');
               print('Please add the following to CHANGELOG.md before release:');
               print('');
               print('## [\$nextVersion] - 2024-XX-XX');
               print('- Your changes here...');
               print('-------------------------------------------------------');
               exit(1);
            }
            print('‚úÖ Changelog entry found for \$nextVersion');

            // 5. Update pubspec.yaml
            final newLines = lines.map((line) {
              if (line.trim().startsWith('version:')) {
                return 'version: \$nextVersion';
              }
              return line;
            }).toList();
            
            await pubspecFile.writeAsString(newLines.join('\n') + '\n');
            
            // Output for GitHub Actions
            if (Platform.environment.containsKey('GITHUB_ENV')) {
              File(Platform.environment['GITHUB_ENV']!).writeAsStringSync('NEW_VERSION=\$nextVersion\n', mode: FileMode.append);
            } else {
              print('Warning: GITHUB_ENV not found. Running locally? Set NEW_VERSION=\$nextVersion manually.');
            }
          }

          List<int> _parseVersion(String v) {
            return v.split('+')[0].split('.').map(int.parse).toList();
          }

          bool _isGreater(List<int> a, List<int> b) {
            if (a[0] > b[0]) return true;
            if (a[0] < b[0]) return false;
            if (a[1] > b[1]) return true;
            if (a[1] < b[1]) return false;
            return a[2] > b[2];
          }

          bool _isEqual(List<int> a, List<int> b) {
             return a[0] == b[0] && a[1] == b[1] && a[2] == b[2];
          }
          EOF

          # Run the script
          dart run bump_version.dart
          
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit and Push Release
        run: |
          git add pubspec.yaml
          
          if ! git diff-index --quiet HEAD; then
            # We use the env var NEW_VERSION here which was set by the bump step
            git commit -m "chore: bump version to ${{ env.NEW_VERSION }}"
            git tag -f "v${{ env.NEW_VERSION }}"
            git push origin main
            git push -f origin "v${{ env.NEW_VERSION }}"
          else
             echo "No changes to commit."
          fi

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ env.NEW_VERSION }}
          name: v${{ env.NEW_VERSION }}
          generate_release_notes: true
