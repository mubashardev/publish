name: CD - Auto Bump Version

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write

jobs:
  bump:
    runs-on: ubuntu-latest
    if: "endsWith(github.event.head_commit.message, '[release]') || github.event_name == 'workflow_dispatch'"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GH_PAT }}

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: 'stable'
          flutter-version: '3.22.0'

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Install dependencies
        run: flutter pub get

      - name: Generate Release Notes
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        run: |
          cat <<EOF > generate_notes.dart
          import 'dart:io';
          import 'dart:convert';

          void main(List<String> args) async {
            final start = args[0];
            final end = args[1];
            final apiKey = Platform.environment['OPENROUTER_API_KEY'];
            
            // Get commits between range
            final result = await Process.run('git', ['log', '--pretty=format:%s', '\$start..\$end']);
            final commitLog = result.stdout as String;
            final lines = commitLog.split('\n').where((l) => l.trim().isNotEmpty).toList();

            if (lines.isEmpty) {
               File('release_notes.txt').writeAsStringSync("No significant changes.");
               return;
            }

            // Try AI generation if Key is present
            if (apiKey != null && apiKey.isNotEmpty) {
              try {
                print('‚ú® specific API Key found! Asking AI to summarize...');
                await _generateWithAI(apiKey, commitLog);
                return;
              } catch (e) {
                print('‚ùå AI generation failed: \$e');
                print('Falling back to local summarizer...');
              }
            } else {
              print('‚ÑπÔ∏è No OPENROUTER_API_KEY found. Using local summarizer.');
            }

            // Fallback: Local Logic
            _generateLocally(lines);
            exit(0);
          }

          Future<void> _generateWithAI(String apiKey, String commitLog) async {
            final url = Uri.parse('https://openrouter.ai/api/v1/chat/completions');
            final client = HttpClient();
            try {
              final request = await client.postUrl(url);
              
              request.headers.set('Authorization', 'Bearer \$apiKey');
              request.headers.set('Content-Type', 'application/json');
              request.headers.set('HTTP-Referer', 'https://github.com/mubashardev/publish'); 
              request.headers.set('X-Title', 'Publish Workflow');

              final prompt = '''
              You are a technical writer for a Flutter package. 
              Summarize the following commit messages into a high-quality, readable changelog.
              
              Rules:
              1. Group changes into "Features", "Bug Fixes", "Breaking Changes", and "Improvements".
              2. Ignore "chore", "release", or noise commits.
              3. Use bullet points.
              4. Be concise but descriptive. 
              5. Output ONLY the markdown content, no introductory text.

              Commits:
              \$commitLog
              ''';

              final body = jsonEncode({
                "model": "google/gemini-1.5-flash",
                "messages": [
                  {"role": "user", "content": prompt}
                ]
              });

              request.write(body);
              final response = await request.close();
              
              if (response.statusCode == 200) {
                final responseBody = await response.transform(utf8.decoder).join();
                final json = jsonDecode(responseBody);
                final content = json['choices'][0]['message']['content'];
                File('release_notes.txt').writeAsStringSync(content);
                print('‚úÖ AI Release notes generated successfully!');
              } else {
                throw Exception('API returned status \${response.statusCode}');
              }
            } finally {
              client.close();
            }
          }

          void _generateLocally(List<String> lines) {
            final features = <String>[];
            final fixes = <String>[];
            final other = <String>[];
            
            for (var line in lines) {
              var cleanLine = line.trim();
              final lower = cleanLine.toLowerCase();
              
              if (lower.startsWith('chore: bump version')) continue; 
              if (lower.contains('[release]')) continue;

              cleanLine = cleanLine.replaceAll(RegExp(r'^(feat|fix|chore|docs|style|refactor|perf|test)\s*:\s*', caseSensitive: false), '');
              if (cleanLine.isNotEmpty) {
                 cleanLine = cleanLine[0].toUpperCase() + cleanLine.substring(1);
              }
              
              if (lower.startsWith('feat') || lower.startsWith('add') || lower.startsWith('new')) {
                features.add(cleanLine);
              } else if (lower.startsWith('fix') || lower.startsWith('bug') || lower.startsWith('resolve')) {
                fixes.add(cleanLine);
              } else {
                other.add(cleanLine);
              }
            }
            
            final buffer = StringBuffer();
            if (features.isNotEmpty) {
              buffer.writeln('### ‚ú® Features');
              for (var l in features) buffer.writeln('- \$l');
              buffer.writeln();
            }
            if (fixes.isNotEmpty) {
              buffer.writeln('### üêõ Bug Fixes');
              for (var l in fixes) buffer.writeln('- \$l');
              buffer.writeln();
            }
            if (other.isNotEmpty) {
              buffer.writeln('### üîß Improvements');
              for (var l in other) buffer.writeln('- \$l');
            }
            if (buffer.isEmpty) buffer.writeln('No user-facing changes.');
            
            File('release_notes.txt').writeAsStringSync(buffer.toString());
          }
          EOF

          # Find the previous commit that had [release] in the message
          # Since HEAD also has [release], skip=1 finds the PREVIOUS one.
          LAST_RELEASE_SHA=$(git log --format="%H" --grep="\[release\]" --skip=1 -n 1)

          if [ -z "$LAST_RELEASE_SHA" ]; then
            echo "No previous release found. Using first commit."
            # Fallback to the very first commit if no previous release tag found
            LAST_RELEASE_SHA=$(git rev-list --max-parents=0 HEAD)
          fi
          
          echo "Generating notes from $LAST_RELEASE_SHA to HEAD"
          dart run generate_notes.dart $LAST_RELEASE_SHA HEAD
          
          echo "Release Notes Content:"
          cat release_notes.txt

      - name: Auto-Bump Version
        id: bump
        run: |
          # Create a Dart script to handle the smart version bumping
          cat <<EOF > bump_version.dart
          import 'dart:io';
          import 'dart:convert';

          void main() async {
            // 1. Read local pubspec.yaml
            final pubspecFile = File('pubspec.yaml');
            final lines = await pubspecFile.readAsLines();
            String? name;
            String? localVersionStr;
            
            for (var line in lines) {
              if (line.trim().startsWith('name:')) {
                name = line.split(':')[1].trim();
              } else if (line.trim().startsWith('version:')) {
                localVersionStr = line.split(':')[1].trim();
              }
            }

            if (name == null || localVersionStr == null) {
              print('Error: Could not find name or version in pubspec.yaml');
              exit(1);
            }

            print('Package: \$name');
            print('Local Version: \$localVersionStr');

            // 2. Fetch latest version from pub.dev
            String? publishedVersionStr;
            final client = HttpClient();
            try {
              final url = Uri.parse('https://pub.dev/api/packages/\$name');
              final request = await client.getUrl(url);
              final response = await request.close();
              if (response.statusCode == 200) {
                final body = await response.transform(utf8.decoder).join();
                final json = jsonDecode(body);
                publishedVersionStr = json['latest']['version'];
                print('Published Version: \$publishedVersionStr');
              } else {
                print('Package not found on pub.dev or API error (Status \${response.statusCode}). Assuming first release.');
              }
            } catch (e) {
              print('Error checking pub.dev: \$e');
            } finally {
              client.close();
            }

            // 3. Determine Next Version
            String nextVersion = localVersionStr!;
            if (publishedVersionStr != null) {
              final local = _parseVersion(localVersionStr);
              final published = _parseVersion(publishedVersionStr);

              if (_isGreater(published, local) || _isEqual(published, local)) {
                // If published is >= local, we must bump published to get next
                // Defaulting to patch bump
                nextVersion = '\${published[0]}.\${published[1]}.\${published[2] + 1}';
                print('Published version >= Local version. Bumping to \$nextVersion');
              } else {
                print('Local version is already ahead. Using \$nextVersion');
              }
            }

            // 4. Update pubspec.yaml
            final newLines = lines.map((line) {
              if (line.trim().startsWith('version:')) {
                return 'version: \$nextVersion';
              }
              return line;
            }).toList();
            
            await pubspecFile.writeAsString(newLines.join('\n') + '\n');
            
            // Output for GitHub Actions
            File(Platform.environment['GITHUB_ENV']!).writeAsStringSync('NEW_VERSION=\$nextVersion\n', mode: FileMode.append);
          }

          List<int> _parseVersion(String v) {
            return v.split('+')[0].split('.').map(int.parse).toList();
          }

          bool _isGreater(List<int> a, List<int> b) {
            if (a[0] > b[0]) return true;
            if (a[0] < b[0]) return false;
            if (a[1] > b[1]) return true;
            if (a[1] < b[1]) return false;
            return a[2] > b[2];
          }

          bool _isEqual(List<int> a, List<int> b) {
             return a[0] == b[0] && a[1] == b[1] && a[2] == b[2];
          }
          EOF

          # Run the script
          dart run bump_version.dart

          # Commit the change
          NEW_VERSION=${{ env.NEW_VERSION }} # This var might not be available yet in this step block, relying on script writing to env
          # We need to reload the env or just read it from the file we just wrote? 
          # Actually, 'dart run' will finish, then we can read the env var in the NEXT step or rely on git diff.
          
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update CHANGELOG
        run: |
          # Get current date
          DATE=$(date +%Y-%m-%d)
          
          # Prepare the new entry
          echo "## [${{ env.NEW_VERSION }}] - $DATE" > new_entry.md
          cat release_notes.txt >> new_entry.md
          echo "" >> new_entry.md # Add spacing
          
          # Prepend to existing CHANGELOG.md
          if [ -f "CHANGELOG.md" ]; then
            cat CHANGELOG.md >> new_entry.md
          fi
          mv new_entry.md CHANGELOG.md

      - name: Commit and Push Release
        run: |
          git add pubspec.yaml CHANGELOG.md
          
          if ! git diff-index --quiet HEAD; then
            # We use the env var NEW_VERSION here which was set by the bump step
            git commit -m "chore: bump version to ${{ env.NEW_VERSION }}"
            git tag -f "v${{ env.NEW_VERSION }}"
            git push origin main
            git push -f origin "v${{ env.NEW_VERSION }}"
          else
             echo "No changes to commit."
          fi

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ env.NEW_VERSION }}
          name: v${{ env.NEW_VERSION }}
          body_path: release_notes.txt
